{"ast":null,"code":"import { useCallback } from 'react';\nimport { findDOMNode } from 'react-dom';\nlet hadKeyboardEvent = true;\nlet hadFocusVisibleRecently = false;\nlet hadFocusVisibleRecentlyTimeout;\nconst inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  \"datetime-local\": true\n};\nfunction focusTriggersKeyboardModality(node) {\n  if (\"type\" in node) {\n    const {\n      type,\n      tagName\n    } = node;\n    if (tagName === \"INPUT\" && inputTypesWhitelist[type] && !node.readOnly) {\n      return true;\n    }\n    if (tagName === \"TEXTAREA\" && !node.readOnly) {\n      return true;\n    }\n  }\n  if (\"isContentEditable\" in node && node.isContentEditable) {\n    return true;\n  }\n  return false;\n}\nfunction handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n  hadKeyboardEvent = true;\n}\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\nfunction handleVisibilityChange() {\n  if (this.visibilityState === \"hidden\") {\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\nfunction prepare(doc) {\n  doc.addEventListener(\"keydown\", handleKeyDown, true);\n  doc.addEventListener(\"mousedown\", handlePointerDown, true);\n  doc.addEventListener(\"pointerdown\", handlePointerDown, true);\n  doc.addEventListener(\"touchstart\", handlePointerDown, true);\n  doc.addEventListener(\"visibilitychange\", handleVisibilityChange, true);\n}\nfunction isFocusVisible(event) {\n  const {\n    target\n  } = event;\n  try {\n    return target.matches(\":focus-visible\");\n  } catch (error) {}\n  return hadKeyboardEvent || focusTriggersKeyboardModality(target);\n}\nfunction handleBlurVisible() {\n  hadFocusVisibleRecently = true;\n  window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n  hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {\n    hadFocusVisibleRecently = false;\n  }, 100);\n}\nfunction useIsFocusVisible() {\n  const ref = useCallback(instance => {\n    const node = findDOMNode(instance);\n    if (node != null) {\n      prepare(node.ownerDocument);\n    }\n  }, []);\n  return {\n    isFocusVisible,\n    onBlurVisible: handleBlurVisible,\n    ref\n  };\n}\nexport { useIsFocusVisible };","map":{"version":3,"names":["useCallback","findDOMNode","hadKeyboardEvent","hadFocusVisibleRecently","hadFocusVisibleRecentlyTimeout","inputTypesWhitelist","text","search","url","tel","email","password","number","date","month","week","time","datetime","focusTriggersKeyboardModality","node","type","tagName","readOnly","isContentEditable","handleKeyDown","event","metaKey","altKey","ctrlKey","handlePointerDown","handleVisibilityChange","visibilityState","prepare","doc","addEventListener","isFocusVisible","target","matches","error","handleBlurVisible","window","clearTimeout","setTimeout","useIsFocusVisible","ref","instance","ownerDocument","onBlurVisible"],"sources":["/Users/danielbednarski/darighost.github.io/node_modules/react95/dist/common/hooks/useIsFocusVisible.mjs"],"sourcesContent":["import { useCallback } from 'react';\nimport { findDOMNode } from 'react-dom';\n\nlet hadKeyboardEvent = true;\nlet hadFocusVisibleRecently = false;\nlet hadFocusVisibleRecentlyTimeout;\nconst inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  \"datetime-local\": true\n};\nfunction focusTriggersKeyboardModality(node) {\n  if (\"type\" in node) {\n    const { type, tagName } = node;\n    if (tagName === \"INPUT\" && inputTypesWhitelist[type] && !node.readOnly) {\n      return true;\n    }\n    if (tagName === \"TEXTAREA\" && !node.readOnly) {\n      return true;\n    }\n  }\n  if (\"isContentEditable\" in node && node.isContentEditable) {\n    return true;\n  }\n  return false;\n}\nfunction handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n  hadKeyboardEvent = true;\n}\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\nfunction handleVisibilityChange() {\n  if (this.visibilityState === \"hidden\") {\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\nfunction prepare(doc) {\n  doc.addEventListener(\"keydown\", handleKeyDown, true);\n  doc.addEventListener(\"mousedown\", handlePointerDown, true);\n  doc.addEventListener(\"pointerdown\", handlePointerDown, true);\n  doc.addEventListener(\"touchstart\", handlePointerDown, true);\n  doc.addEventListener(\"visibilitychange\", handleVisibilityChange, true);\n}\nfunction isFocusVisible(event) {\n  const { target } = event;\n  try {\n    return target.matches(\":focus-visible\");\n  } catch (error) {\n  }\n  return hadKeyboardEvent || focusTriggersKeyboardModality(target);\n}\nfunction handleBlurVisible() {\n  hadFocusVisibleRecently = true;\n  window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n  hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {\n    hadFocusVisibleRecently = false;\n  }, 100);\n}\nfunction useIsFocusVisible() {\n  const ref = useCallback((instance) => {\n    const node = findDOMNode(instance);\n    if (node != null) {\n      prepare(node.ownerDocument);\n    }\n  }, []);\n  return { isFocusVisible, onBlurVisible: handleBlurVisible, ref };\n}\n\nexport { useIsFocusVisible };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}